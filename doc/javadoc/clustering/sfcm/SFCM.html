<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_22) on Mon Jan 24 18:53:48 CET 2011 -->
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<TITLE>
SFCM (SFCM)
</TITLE>

<META NAME="date" CONTENT="2011-01-24">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="SFCM (SFCM)";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/SFCM.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../clustering/sfcm/ClusteringValidity.html" title="class in clustering.sfcm"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../clustering/sfcm/SFCMManager.html" title="class in clustering.sfcm"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?clustering/sfcm/SFCM.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="SFCM.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
clustering.sfcm</FONT>
<BR>
Class SFCM</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../resources/inherit.gif" ALT="extended by "><B>clustering.sfcm.SFCM</B>
</PRE>
<HR>
<DL>
<DT><PRE>public class <B>SFCM</B><DT>extends java.lang.Object</DL>
</PRE>

<P>
This class encapsulates the Spatial Fuzzy C-Means as proposed in: <i>Chuang,
 Tzeng, Chen Fuzzy c-means clustering with spatial information for image
 segmentation. Computerized Medical Imaging and Graphics 30 (2006) 9–15</i>.
 It implements the Singleton pattern and provides as the only public class
 method @link{run}. It also implements the delegation pattern, being free from
 ImageJ API it can be  more easily reused
<P>

<P>
<HR>

<P>
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Field Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../clustering/sfcm/SFCM.html#zeroCorrection">zeroCorrection</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A double value used for correcting numerical error when the spatial function
 computed while updating the cluster membership matrix <code>U</code> equals 0
 for each samples for a given cluster.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../clustering/sfcm/SFCM.html#SFCM()">SFCM</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The class constructor is private in order to prevent the class from being
 instantiated</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private static&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../clustering/sfcm/SFCM.html#checkConvergence(float[][], float[][], float[][], float[][], int)">checkConvergence</A></B>(float[][]&nbsp;U,
                 float[][]&nbsp;oldU,
                 float[][]&nbsp;V,
                 float[][]&nbsp;oldV,
                 int&nbsp;criterion)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Checks for the convergence of the algorithm.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../clustering/sfcm/SFCM.html#closestCluster(float[], float[][], int)">closestCluster</A></B>(float[]&nbsp;x,
               float[][]&nbsp;clusterCenters,
               int&nbsp;k)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the index of the closest cluster to point <code>x</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private static&nbsp;java.lang.Object[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../clustering/sfcm/SFCM.html#clusterize(float[][], float[][], float[][], int, double, clustering.sfcm.ClusteringDelegate, double, long, int, int, double, double, int, int, boolean)">clusterize</A></B>(float[][]&nbsp;X,
           float[][]&nbsp;U,
           float[][]&nbsp;V,
           int&nbsp;k,
           double&nbsp;tolerance,
           <A HREF="../../clustering/sfcm/ClusteringDelegate.html" title="interface in clustering.sfcm">ClusteringDelegate</A>&nbsp;delegate,
           double&nbsp;m,
           long&nbsp;iterations,
           int&nbsp;stopCriterion,
           int&nbsp;r,
           double&nbsp;p,
           double&nbsp;q,
           int&nbsp;spatialFunction,
           int&nbsp;width,
           boolean&nbsp;testing)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Clusterize is the main method that orchestrates all the steps of the
 <i>Spatial Fuzzy C-Means</i>algorithm.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private static&nbsp;float[][]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../clustering/sfcm/SFCM.html#computeExponentialMembership(float[][], float[][], double)">computeExponentialMembership</A></B>(float[][]&nbsp;U,
                             float[][]&nbsp;Um,
                             double&nbsp;m)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computes the exponential memberhip matrix <code>U</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private static&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../clustering/sfcm/SFCM.html#computeObjectiveFunction(float[][], float[][], float[][], double[][])">computeObjectiveFunction</A></B>(float[][]&nbsp;X,
                         float[][]&nbsp;Um,
                         float[][]&nbsp;V,
                         double[][]&nbsp;D)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computes the objective function <b>J</b> as proposed in the <i>Fuzzy C-Means</i>
 algorithm.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private static&nbsp;java.util.Random</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../clustering/sfcm/SFCM.html#createRandom(int)">createRandom</A></B>(int&nbsp;randomSeed)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a <i>Random</i> instance using a seed</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private static&nbsp;int[][]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../clustering/sfcm/SFCM.html#defuzzyfyClusterMemberships(float[][])">defuzzyfyClusterMemberships</A></B>(float[][]&nbsp;U)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computes the defuzzyfication of the cluster membership matrix <code>U</code>
 by using a max operator on the membership values of a sample against all the
 clusters.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../clustering/sfcm/SFCM.html#euclideanDistance(float[], float[])">euclideanDistance</A></B>(float[]&nbsp;a,
                  float[]&nbsp;b)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Euclidean distance  computed between points <code>a</code> and <code>b</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private static&nbsp;double[][]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../clustering/sfcm/SFCM.html#euclideanDistanceMatrix(float[][], float[][], double[][], double)">euclideanDistanceMatrix</A></B>(float[][]&nbsp;A,
                        float[][]&nbsp;B,
                        double[][]&nbsp;D,
                        double&nbsp;m)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computes a distance matrix starting from two sample x features matrixes
 It is used to precompute all the distances between the samples and the centroids
 and it is used to update the cluster membership matrix <code>U</code>:
 The distance matrix holds one more column used to precompute the sum of the
 inverse exponentiated distances between all the centroids and a sample.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private static&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../clustering/sfcm/SFCM.html#frobeniusNorm(float[][], float[][])">frobeniusNorm</A></B>(float[][]&nbsp;A,
              float[][]&nbsp;B)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computes the Frobenius norm of the difference matrix between two input matrixes.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private static&nbsp;float[][]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../clustering/sfcm/SFCM.html#initializeClusterMembershipRandom(float[][], int, int)">initializeClusterMembershipRandom</A></B>(float[][]&nbsp;U,
                                  int&nbsp;k,
                                  int&nbsp;randomSeed)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Initializes the cluster membership matrix <code>U</code> randomly by generating
 random values in [0, 1] and normalizing them in order to have the sum of
 membership values for a pixel equal one.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private static&nbsp;java.lang.Object[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../clustering/sfcm/SFCM.html#initializeMatrixes(float[][], float[][], float[][], int, int, int, double)">initializeMatrixes</A></B>(float[][]&nbsp;X,
                   float[][]&nbsp;V,
                   float[][]&nbsp;U,
                   int&nbsp;k,
                   int&nbsp;randomSeed,
                   int&nbsp;initMode,
                   double&nbsp;m)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method initialize the matrixes <code>U</code> and <code>V</code> according
 with the initialization mode specified.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private static&nbsp;float[][]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../clustering/sfcm/SFCM.html#kMeansPlusPlusInitialization(float[][], float[][], int, int)">kMeansPlusPlusInitialization</A></B>(float[][]&nbsp;X,
                             float[][]&nbsp;V,
                             int&nbsp;k,
                             int&nbsp;randomSeed)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Initializes the cluster center matrix <code>V</code> according to the
 <i>K-means++</i> initialization criterion.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../clustering/sfcm/SFCM.html#matrixCopy(float[][], float[][])">matrixCopy</A></B>(float[][]&nbsp;A,
           float[][]&nbsp;B)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implements a not shallow copy between two matrixes.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private static&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../clustering/sfcm/SFCM.html#maxNorm(float[][], float[][])">maxNorm</A></B>(float[][]&nbsp;A,
        float[][]&nbsp;B)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computes the max norm of the difference matrix between two input matrixes.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private static&nbsp;float[][]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../clustering/sfcm/SFCM.html#opt1UpdateMembershipsWithSpatialFunctionG(float[][], int, double, double, int, double[], double[][], short[][])">opt1UpdateMembershipsWithSpatialFunctionG</A></B>(float[][]&nbsp;U,
                                          int&nbsp;rad,
                                          double&nbsp;p,
                                          double&nbsp;q,
                                          int&nbsp;cols,
                                          double[]&nbsp;supC,
                                          double[][]&nbsp;uPhQ,
                                          short[][]&nbsp;G)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computes the update rule of the membership matrix <code>U</code> according
 to the <i>Spatial Fuzzy C-Mean</i> algorithm.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private static&nbsp;float[][]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../clustering/sfcm/SFCM.html#opt1UpdateMembershipsWithSpatialFunctionH(float[][], int, double, double, int, double[], double[][])">opt1UpdateMembershipsWithSpatialFunctionH</A></B>(float[][]&nbsp;U,
                                          int&nbsp;rad,
                                          double&nbsp;p,
                                          double&nbsp;q,
                                          int&nbsp;cols,
                                          double[]&nbsp;supC,
                                          double[][]&nbsp;uPhQ)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computes the update rule of the membership matrix <code>U</code> according
 to the <i>Spatial Fuzzy C-Mean</i> algorithm.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private static&nbsp;float[][]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../clustering/sfcm/SFCM.html#opt2UpdateMembershipsWithSpatialFunctionG(float[][], int, double, double, int, int[][], double[][], short[][])">opt2UpdateMembershipsWithSpatialFunctionG</A></B>(float[][]&nbsp;U,
                                          int&nbsp;rad,
                                          double&nbsp;p,
                                          double&nbsp;q,
                                          int&nbsp;cols,
                                          int[][]&nbsp;sumU,
                                          double[][]&nbsp;uPhQ,
                                          short[][]&nbsp;G)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private static&nbsp;float[][]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../clustering/sfcm/SFCM.html#opt2UpdateMembershipsWithSpatialFunctionH(float[][], int, double, double, int, double[][], double[][])">opt2UpdateMembershipsWithSpatialFunctionH</A></B>(float[][]&nbsp;U,
                                          int&nbsp;rad,
                                          double&nbsp;p,
                                          double&nbsp;q,
                                          int&nbsp;cols,
                                          double[][]&nbsp;sumU,
                                          double[][]&nbsp;uPhQ)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private static&nbsp;int[][]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../clustering/sfcm/SFCM.html#precomputeArrayForm(int, int)">precomputeArrayForm</A></B>(int&nbsp;rows,
                    int&nbsp;columns)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Precomputes in a rows x columns matrix the array form indices associated
 to each pair of matrix form indices.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private static&nbsp;int[][]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../clustering/sfcm/SFCM.html#precomputeMatrixForm(int, int)">precomputeMatrixForm</A></B>(int&nbsp;offset,
                     int&nbsp;width)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Precomputes in a samples x 2 matrix the matrix form indices associated
 to each array form indices.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../clustering/sfcm/SFCM.html#printMatrix(double[][])">printMatrix</A></B>(double[][]&nbsp;A)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Utility method for printing a double matrix on console</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../clustering/sfcm/SFCM.html#printMatrix(float[][])">printMatrix</A></B>(float[][]&nbsp;A)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Utility method for printing a float matrix on console</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private static&nbsp;float[][]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../clustering/sfcm/SFCM.html#randomInitialization(float[][], float[][], int, int)">randomInitialization</A></B>(float[][]&nbsp;X,
                     float[][]&nbsp;V,
                     int&nbsp;k,
                     int&nbsp;randomSeed)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Initializes the cluster center matrix <code>V</code> randomly by selecting
 samples from X and checking not to pick an already selected sample</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Object[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../clustering/sfcm/SFCM.html#run(float[][], int, double, int, int, clustering.sfcm.ClusteringDelegate, double, long, int, int, double, double, int, int, boolean)">run</A></B>(float[][]&nbsp;X,
    int&nbsp;k,
    double&nbsp;tolerance,
    int&nbsp;randomSeed,
    int&nbsp;initMode,
    <A HREF="../../clustering/sfcm/ClusteringDelegate.html" title="interface in clustering.sfcm">ClusteringDelegate</A>&nbsp;delegate,
    double&nbsp;m,
    long&nbsp;iterations,
    int&nbsp;stopCriterion,
    int&nbsp;r,
    double&nbsp;p,
    double&nbsp;q,
    int&nbsp;spatialFunction,
    int&nbsp;width,
    boolean&nbsp;testing)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The only one method that is visible to the other classes,
 it is used for start of the algorithm: it inizializaes the matrixes U and V,
 run the SFCM on them and then pack them in an Object array that returns
 to the caller.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private static&nbsp;float[][]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../clustering/sfcm/SFCM.html#updateClusterCenterMatrix(float[][], float[][], float[][])">updateClusterCenterMatrix</A></B>(float[][]&nbsp;X,
                          float[][]&nbsp;Um,
                          float[][]&nbsp;V)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Updates the cluster center matrix <code>V</code> according to the <i>Fuzzy
 C-Means</i> algorithm.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private static&nbsp;float[][]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../clustering/sfcm/SFCM.html#updateClusterMembershipMatrix(float[][], float[][], float[][], double, double[][])">updateClusterMembershipMatrix</A></B>(float[][]&nbsp;X,
                              float[][]&nbsp;U,
                              float[][]&nbsp;V,
                              double&nbsp;m,
                              double[][]&nbsp;D)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Updates the cluster membership matrix <code>U</code> according to the
 <i>Fuzzy C-Means</i> algorithm.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private static&nbsp;float[][]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../clustering/sfcm/SFCM.html#updateMembershipsWithSpatialInformation(float[][], int, double, double, int, int, int[][], int[][], double[][])">updateMembershipsWithSpatialInformation</A></B>(float[][]&nbsp;U,
                                        int&nbsp;r,
                                        double&nbsp;p,
                                        double&nbsp;q,
                                        int&nbsp;spatialFunctionType,
                                        int&nbsp;cols,
                                        int[][]&nbsp;xy,
                                        int[][]&nbsp;offset,
                                        double[][]&nbsp;uPhQ)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Updates the cluster membership matrix <code>U</code> according to the
 <i>Spatial Fuzzy C-Means</i> algorithm implemented.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Field Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="zeroCorrection"><!-- --></A><H3>
zeroCorrection</H3>
<PRE>
private static double <B>zeroCorrection</B></PRE>
<DL>
<DD>A double value used for correcting numerical error when the spatial function
 computed while updating the cluster membership matrix <code>U</code> equals 0
 for each samples for a given cluster.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../clustering/sfcm/SFCM.html#opt1UpdateMembershipsWithSpatialFunctionG(float[][], int, double, double, int, double[], double[][], short[][])"><CODE>opt1UpdateMembershipsWithSpatialFunctionG(float[][], int, double, double, int, double[], double[][], short[][])</CODE></A></DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="SFCM()"><!-- --></A><H3>
SFCM</H3>
<PRE>
private <B>SFCM</B>()</PRE>
<DL>
<DD>The class constructor is private in order to prevent the class from being
 instantiated
<P>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="run(float[][], int, double, int, int, clustering.sfcm.ClusteringDelegate, double, long, int, int, double, double, int, int, boolean)"><!-- --></A><H3>
run</H3>
<PRE>
public static java.lang.Object[] <B>run</B>(float[][]&nbsp;X,
                                     int&nbsp;k,
                                     double&nbsp;tolerance,
                                     int&nbsp;randomSeed,
                                     int&nbsp;initMode,
                                     <A HREF="../../clustering/sfcm/ClusteringDelegate.html" title="interface in clustering.sfcm">ClusteringDelegate</A>&nbsp;delegate,
                                     double&nbsp;m,
                                     long&nbsp;iterations,
                                     int&nbsp;stopCriterion,
                                     int&nbsp;r,
                                     double&nbsp;p,
                                     double&nbsp;q,
                                     int&nbsp;spatialFunction,
                                     int&nbsp;width,
                                     boolean&nbsp;testing)</PRE>
<DL>
<DD>The only one method that is visible to the other classes,
 it is used for start of the algorithm: it inizializaes the matrixes U and V,
 run the SFCM on them and then pack them in an Object array that returns
 to the caller.
 <p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>X</CODE> - data matrix, a samples x features matrix<DD><CODE>k</CODE> - number of clusters<DD><CODE>tolerance</CODE> - threashold used for checking the convergence of the algorithm<DD><CODE>randomSeed</CODE> - the randomization seed used for generating random numbers<DD><CODE>initMode</CODE> - an integer that specifies the initialization mode for the
 matrixes <code>U</code> and <code>V</code>.
 <b>0</b> - firstly initializes the centroid matrix <code>V</code>
 randomly <i>E. Forgy,
 “Cluster Analysis of Multivariate Data: Effi- ciency vs. Interpretability
 of Classification,” Biometrics, vol. 21, pp. 768, 1965<i/>.
 <b>1</b> - Firstly initializes the centroid matrix <code>V</code> accoding to the
 <i>K-Means++</i> criterion @link{http://en.wikipedia.org/wiki/K-means++}
 <b>2</b> - Firstly initializes the cluster membership matrix <code>U</code> randomly<DD><CODE>delegate</CODE> - is the object which is delegate to output partial results
 of the algorithm.<DD><CODE>m</CODE> - is the fuzzyness parameter<DD><CODE>iterations</CODE> - is the max number of iterations possible for the algorithm<DD><CODE>stopCriterion</CODE> - is an integer representing one of the possible stop criterions:
 <b>0</b> - it computes the Frobenius norm on the difference between the actual
 membership matrix <code>U</code> and the previous one from the last iteration
 <b>1</b> - it computes the Frobenius norm on the difference between the actual
 centroid matrix <code>V</code> and the previous one from the last iteration
 <b>2</b> - it computes the max norm on the difference between the actual
 membership matrix <code>U</code> and the previous one from the last iteration
 <b>3</b> - it computes the max norm on the difference between the actual
 centroid matrix <code>V</code> and the previous one from the last iteration<DD><CODE>r</CODE> - is the radius of the window used to compute the spatial information<DD><CODE>p</CODE> - is the weight for the membership values<DD><CODE>q</CODE> - is the weight for the chosen spatial function <code>h</code><DD><CODE>spatialFunction</CODE> - is an integer representing the choosen spatial function:
 <b>0</b> - Computes the spatial function as the sum of the membership values
 for the samples in the neighborhood according to the same cluster
 <b>1</b> - Computes the spatial function as the number of clusters membership
 in the neighborhood that are the greatest value for the neighbor according to
 that cluster<DD><CODE>width</CODE> - the width of the matrix form, as the samples can be viewed when
 computing the neightborhood for each one<DD><CODE>testing</CODE> - a boolean value that tells whether the algorithm is run for testing
<DT><B>Returns:</B><DD>a vector of object that has three elements: a defuzzyfied memberhip matrix,
 the cluster centroid matrix and the cluster membership matrix<DT><B>See Also:</B><DD><A HREF="../../clustering/sfcm/SFCMManager.html" title="class in clustering.sfcm"><CODE>SFCMManager</CODE></A>, 
<A HREF="../../clustering/sfcm/ClusteringDelegate.html" title="interface in clustering.sfcm"><CODE>ClusteringDelegate</CODE></A>, 
<A HREF="../../clustering/sfcm/SFCM.html#defuzzyfyClusterMemberships(float[][])"><CODE>defuzzyfyClusterMemberships(float[][])</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="initializeMatrixes(float[][], float[][], float[][], int, int, int, double)"><!-- --></A><H3>
initializeMatrixes</H3>
<PRE>
private static java.lang.Object[] <B>initializeMatrixes</B>(float[][]&nbsp;X,
                                                     float[][]&nbsp;V,
                                                     float[][]&nbsp;U,
                                                     int&nbsp;k,
                                                     int&nbsp;randomSeed,
                                                     int&nbsp;initMode,
                                                     double&nbsp;m)</PRE>
<DL>
<DD>This method initialize the matrixes <code>U</code> and <code>V</code> according
 with the initialization mode specified.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>X</CODE> - data matrix<DD><CODE>V</CODE> - cluster center matrix to be initialized<DD><CODE>U</CODE> - cluster membership matrix to be initialized<DD><CODE>k</CODE> - number of clusters<DD><CODE>randomSeed</CODE> - randomization seed used to generate a random sequence<DD><CODE>initMode</CODE> - an integer that specifies the initialization mode for the
 matrixes <code>U</code> and <code>V</code>.
 <b>0</b> - firstly initializes the centroid matrix <code>V</code>
 randomly <i>E. Forgy,
 “Cluster Analysis of Multivariate Data: Effi- ciency vs. Interpretability
 of Classification,” Biometrics, vol. 21, pp. 768, 1965<i/>.
 <b>1</b> - Firstly initializes the centroid matrix <code>V</code> accoding to the
 <i>K-Means++</i> criterion @link{http://en.wikipedia.org/wiki/K-means++}
 <b>2</b> - Firstly initializes the cluster membership matrix <code>U</code> randomly<DD><CODE>delegate</CODE> - is the object which is delegate to output partial results
 of the algorithm.<DD><CODE>m</CODE> - the fuzzyness parameter
<DT><B>Returns:</B><DD>an Object array which containes the initialized <code>U</code>
 and <code>V</code> matrixes<DT><B>See Also:</B><DD><A HREF="../../clustering/sfcm/SFCM.html#randomInitialization(float[][], float[][], int, int)"><CODE>randomInitialization(float[][], float[][], int, int)</CODE></A>, 
<A HREF="../../clustering/sfcm/SFCM.html#updateClusterMembershipMatrix(float[][], float[][], float[][], double, double[][])"><CODE>updateClusterMembershipMatrix(float[][], float[][], float[][], double, double[][])</CODE></A>, 
<A HREF="../../clustering/sfcm/SFCM.html#kMeansPlusPlusInitialization(float[][], float[][], int, int)"><CODE>kMeansPlusPlusInitialization(float[][], float[][], int, int)</CODE></A>, 
<A HREF="../../clustering/sfcm/SFCM.html#initializeClusterMembershipRandom(float[][], int, int)"><CODE>initializeClusterMembershipRandom(float[][], int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="printMatrix(float[][])"><!-- --></A><H3>
printMatrix</H3>
<PRE>
private static void <B>printMatrix</B>(float[][]&nbsp;A)</PRE>
<DL>
<DD>Utility method for printing a float matrix on console
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>A</CODE> - the matrix to be printed</DL>
</DD>
</DL>
<HR>

<A NAME="printMatrix(double[][])"><!-- --></A><H3>
printMatrix</H3>
<PRE>
private static void <B>printMatrix</B>(double[][]&nbsp;A)</PRE>
<DL>
<DD>Utility method for printing a double matrix on console
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>A</CODE> - the matrix to be printed</DL>
</DD>
</DL>
<HR>

<A NAME="initializeClusterMembershipRandom(float[][], int, int)"><!-- --></A><H3>
initializeClusterMembershipRandom</H3>
<PRE>
private static float[][] <B>initializeClusterMembershipRandom</B>(float[][]&nbsp;U,
                                                           int&nbsp;k,
                                                           int&nbsp;randomSeed)</PRE>
<DL>
<DD>Initializes the cluster membership matrix <code>U</code> randomly by generating
 random values in [0, 1] and normalizing them in order to have the sum of
 membership values for a pixel equal one.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>U</CODE> - cluster membership matrix to be initialized<DD><CODE>k</CODE> - number of clusters<DD><CODE>randomSeed</CODE> - randomization seed used to generate a random sequence
<DT><B>Returns:</B><DD>the initialized cluster membership matrix<DT><B>See Also:</B><DD><A HREF="../../clustering/sfcm/SFCM.html#initializeMatrixes(float[][], float[][], float[][], int, int, int, double)"><CODE>initializeMatrixes(float[][], float[][], float[][], int, int, int, double)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="randomInitialization(float[][], float[][], int, int)"><!-- --></A><H3>
randomInitialization</H3>
<PRE>
private static float[][] <B>randomInitialization</B>(float[][]&nbsp;X,
                                              float[][]&nbsp;V,
                                              int&nbsp;k,
                                              int&nbsp;randomSeed)</PRE>
<DL>
<DD>Initializes the cluster center matrix <code>V</code> randomly by selecting
 samples from X and checking not to pick an already selected sample
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>X</CODE> - data matrix<DD><CODE>V</CODE> - cluster centroid matrix to be initialized<DD><CODE>k</CODE> - number of clusters<DD><CODE>randomSeed</CODE> - randomization seed used to generate a random sequence
<DT><B>Returns:</B><DD>the initialized cluster matrix<DT><B>See Also:</B><DD><A HREF="../../clustering/sfcm/SFCM.html#initializeMatrixes(float[][], float[][], float[][], int, int, int, double)"><CODE>initializeMatrixes(float[][], float[][], float[][], int, int, int, double)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="kMeansPlusPlusInitialization(float[][], float[][], int, int)"><!-- --></A><H3>
kMeansPlusPlusInitialization</H3>
<PRE>
private static float[][] <B>kMeansPlusPlusInitialization</B>(float[][]&nbsp;X,
                                                      float[][]&nbsp;V,
                                                      int&nbsp;k,
                                                      int&nbsp;randomSeed)</PRE>
<DL>
<DD>Initializes the cluster center matrix <code>V</code> according to the
 <i>K-means++</i> initialization criterion. The first centroid is selected
 randomly from the samples and the remaining ones are selected according
 to a weighted probability distribution on the squared distance from the samples
 and the nearest centroid, chosen from thealready selected centroids.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>X</CODE> - the data matrix<DD><CODE>V</CODE> - the centroid matrix to be initialized<DD><CODE>k</CODE> - the number of clusters<DD><CODE>randomSeed</CODE> - randomization seed used to generate a random sequence
<DT><B>Returns:</B><DD>the initialized cluster center matrix<DT><B>See Also:</B><DD><A HREF="../../clustering/sfcm/SFCM.html#initializeMatrixes(float[][], float[][], float[][], int, int, int, double)"><CODE>initializeMatrixes(float[][], float[][], float[][], int, int, int, double)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="createRandom(int)"><!-- --></A><H3>
createRandom</H3>
<PRE>
private static java.util.Random <B>createRandom</B>(int&nbsp;randomSeed)</PRE>
<DL>
<DD>Creates a <i>Random</i> instance using a seed
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>randomSeed</CODE> - an integer used to generate the Random instance
<DT><B>Returns:</B><DD>the created instance<DT><B>See Also:</B><DD><A HREF="../../clustering/sfcm/SFCM.html#initializeMatrixes(float[][], float[][], float[][], int, int, int, double)"><CODE>initializeMatrixes(float[][], float[][], float[][], int, int, int, double)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="closestCluster(float[], float[][], int)"><!-- --></A><H3>
closestCluster</H3>
<PRE>
private static int <B>closestCluster</B>(float[]&nbsp;x,
                                  float[][]&nbsp;clusterCenters,
                                  int&nbsp;k)</PRE>
<DL>
<DD>Returns the index of the closest cluster to point <code>x</code>.
 Called in the K-Means++ initialization of the cluster centers matrix
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - a sample as an array of float.<DD><CODE>clusterCenters</CODE> - cluster centers matrix.<DD><CODE>k</CODE> - number of clusters
<DT><B>Returns:</B><DD>index of the closest cluster<DT><B>See Also:</B><DD><A HREF="../../clustering/sfcm/SFCM.html#kMeansPlusPlusInitialization(float[][], float[][], int, int)"><CODE>kMeansPlusPlusInitialization(float[][], float[][], int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="euclideanDistance(float[], float[])"><!-- --></A><H3>
euclideanDistance</H3>
<PRE>
private static double <B>euclideanDistance</B>(float[]&nbsp;a,
                                        float[]&nbsp;b)</PRE>
<DL>
<DD>Euclidean distance  computed between points <code>a</code> and <code>b</code>.
 This is the squared rooted version
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>a</CODE> - first point.<DD><CODE>b</CODE> - second point.
<DT><B>Returns:</B><DD>the euclidean distance computed.</DL>
</DD>
</DL>
<HR>

<A NAME="euclideanDistanceMatrix(float[][], float[][], double[][], double)"><!-- --></A><H3>
euclideanDistanceMatrix</H3>
<PRE>
private static double[][] <B>euclideanDistanceMatrix</B>(float[][]&nbsp;A,
                                                  float[][]&nbsp;B,
                                                  double[][]&nbsp;D,
                                                  double&nbsp;m)</PRE>
<DL>
<DD>Computes a distance matrix starting from two sample x features matrixes
 It is used to precompute all the distances between the samples and the centroids
 and it is used to update the cluster membership matrix <code>U</code>:
 The distance matrix holds one more column used to precompute the sum of the
 inverse exponentiated distances between all the centroids and a sample. In this way
 the update rule for the <code>U</code> matrix is more efficiently computed
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>A</CODE> - sample x feature matrix<DD><CODE>B</CODE> - sample x feature matrix<DD><CODE>D</CODE> - distance matrix, if null it will be instantiated<DD><CODE>m</CODE> - fuzzyness parameter
<DT><B>Returns:</B><DD>the instantiated distance matrix<DT><B>See Also:</B><DD><A HREF="../../clustering/sfcm/SFCM.html#updateClusterMembershipMatrix(float[][], float[][], float[][], double, double[][])"><CODE>updateClusterMembershipMatrix(float[][], float[][], float[][], double, double[][])</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="computeExponentialMembership(float[][], float[][], double)"><!-- --></A><H3>
computeExponentialMembership</H3>
<PRE>
private static float[][] <B>computeExponentialMembership</B>(float[][]&nbsp;U,
                                                      float[][]&nbsp;Um,
                                                      double&nbsp;m)</PRE>
<DL>
<DD>Computes the exponential memberhip matrix <code>U</code>.
 It stores the result in a matrix <code>Um</code> conformed to <code>U</code>.
 If the objective function shall be not computed anymore this method can be
 deprecated and the the exponentiation computed when necessary in the update
 rule for the centroid matrix <code>V</code>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>U</CODE> - cluster membership matrix<DD><CODE>Um</CODE> - exponentiated cluster membership matrix, if null it will be instantiated<DD><CODE>m</CODE> - the fuzzyness parameter
<DT><B>Returns:</B><DD>the exponentiated Um matrix<DT><B>See Also:</B><DD><A HREF="../../clustering/sfcm/SFCM.html#updateClusterCenterMatrix(float[][], float[][], float[][])"><CODE>updateClusterCenterMatrix(float[][], float[][], float[][])</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="computeObjectiveFunction(float[][], float[][], float[][], double[][])"><!-- --></A><H3>
computeObjectiveFunction</H3>
<PRE>
private static float <B>computeObjectiveFunction</B>(float[][]&nbsp;X,
                                              float[][]&nbsp;Um,
                                              float[][]&nbsp;V,
                                              double[][]&nbsp;D)</PRE>
<DL>
<DD>Computes the objective function <b>J</b> as proposed in the <i>Fuzzy C-Means</i>
 algorithm. It is used as a possible criterion to check the convergence in the
 testing mode (when the difference between the current value and the previous
 iteration one is sent to the delegate)
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>X</CODE> - the data matrix.<DD><CODE>Um</CODE> - the exponentiated cluster membership matrix.<DD><CODE>V</CODE> - the cluster center matrix.<DD><CODE>D</CODE> - the distance matrix.
<DT><B>Returns:</B><DD>the value of objective function<DT><B>See Also:</B><DD><A HREF="../../clustering/sfcm/SFCM.html#clusterize(float[][], float[][], float[][], int, double, clustering.sfcm.ClusteringDelegate, double, long, int, int, double, double, int, int, boolean)"><CODE>clusterize(float[][], float[][], float[][], int,
 double, clustering.sfcm.ClusteringDelegate, double, long,
 int, int, double, double, int, int, boolean)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="updateClusterMembershipMatrix(float[][], float[][], float[][], double, double[][])"><!-- --></A><H3>
updateClusterMembershipMatrix</H3>
<PRE>
private static float[][] <B>updateClusterMembershipMatrix</B>(float[][]&nbsp;X,
                                                       float[][]&nbsp;U,
                                                       float[][]&nbsp;V,
                                                       double&nbsp;m,
                                                       double[][]&nbsp;D)</PRE>
<DL>
<DD>Updates the cluster membership matrix <code>U</code> according to the
 <i>Fuzzy C-Means</i> algorithm.
 Each value of <code>U</code> is updated as the division between the sum of
 the exponentiated inverse distances between the sample and all the centroids
 and the exponentiated distance between the sample and the current centroid
 It uses the precomputed matrix D in order to speed the computation up.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>X</CODE> - the data matrix<DD><CODE>U</CODE> - the cluster membership matrix to be updated<DD><CODE>V</CODE> - the cluster centroid matrix<DD><CODE>m</CODE> - the fuzzyness parameter used in the exponentiation<DD><CODE>D</CODE> - the distance matrix with an additional column with precomputed values
<DT><B>Returns:</B><DD>the updated  cluster membership matrix<DT><B>See Also:</B><DD><A HREF="../../clustering/sfcm/SFCM.html#clusterize(float[][], float[][], float[][], int, double, clustering.sfcm.ClusteringDelegate, double, long, int, int, double, double, int, int, boolean)"><CODE>clusterize(float[][], float[][], float[][], int, double,
 clustering.sfcm.ClusteringDelegate, double, long, int, int, double,
 double, int, int, boolean)</CODE></A>, 
<A HREF="../../clustering/sfcm/SFCM.html#euclideanDistanceMatrix(float[][], float[][], double[][], double)"><CODE>euclideanDistanceMatrix(float[][], float[][], double[][], double)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="updateClusterCenterMatrix(float[][], float[][], float[][])"><!-- --></A><H3>
updateClusterCenterMatrix</H3>
<PRE>
private static float[][] <B>updateClusterCenterMatrix</B>(float[][]&nbsp;X,
                                                   float[][]&nbsp;Um,
                                                   float[][]&nbsp;V)</PRE>
<DL>
<DD>Updates the cluster center matrix <code>V</code> according to the <i>Fuzzy
 C-Means</i> algorithm.
 Each element of  <code>V</code> is updated considering the sum of the samples
 multiplied by their exponentiated membership and normalized against the
 sum of the exponentiated memberships.
 It uses the already exponentiated matrix <code>Um</code>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>X</CODE> - data matrix<DD><CODE>Um</CODE> - exponentiated cluster membership matrix<DD><CODE>V</CODE> - cluster center matrix to update
<DT><B>Returns:</B><DD>the updated cluster center matrix<DT><B>See Also:</B><DD><A HREF="../../clustering/sfcm/SFCM.html#clusterize(float[][], float[][], float[][], int, double, clustering.sfcm.ClusteringDelegate, double, long, int, int, double, double, int, int, boolean)"><CODE>clusterize(float[][], float[][], float[][], int, double,
 clustering.sfcm.ClusteringDelegate, double, long, int, int, double,
 double, int, int, boolean)</CODE></A>, 
<A HREF="../../clustering/sfcm/SFCM.html#computeExponentialMembership(float[][], float[][], double)"><CODE>computeExponentialMembership(float[][], float[][], double)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="defuzzyfyClusterMemberships(float[][])"><!-- --></A><H3>
defuzzyfyClusterMemberships</H3>
<PRE>
private static int[][] <B>defuzzyfyClusterMemberships</B>(float[][]&nbsp;U)</PRE>
<DL>
<DD>Computes the defuzzyfication of the cluster membership matrix <code>U</code>
 by using a max operator on the membership values of a sample against all the
 clusters.
 It instantiates a new matrix of integers containing only 1 or 0 (hard partition)
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>U</CODE> - the cluster membership matrix
<DT><B>Returns:</B><DD>the hard partition matrix<DT><B>See Also:</B><DD><A HREF="../../clustering/sfcm/SFCM.html#run(float[][], int, double, int, int, clustering.sfcm.ClusteringDelegate, double, long, int, int, double, double, int, int, boolean)"><CODE>run(float[][], int, double, int, int,
 clustering.sfcm.ClusteringDelegate, double, long, int, int, double,
 double, int, int, boolean)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="matrixCopy(float[][], float[][])"><!-- --></A><H3>
matrixCopy</H3>
<PRE>
private static void <B>matrixCopy</B>(float[][]&nbsp;A,
                               float[][]&nbsp;B)</PRE>
<DL>
<DD>Implements a not shallow copy between two matrixes. It is used to save the
 previous iteration matrixes <code>U</code> and <code>V</code>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>A</CODE> - the source matrix<DD><CODE>B</CODE> - the destination matrix<DT><B>See Also:</B><DD><CODE>System.arraycopy</CODE>, 
<A HREF="../../clustering/sfcm/SFCM.html#clusterize(float[][], float[][], float[][], int, double, clustering.sfcm.ClusteringDelegate, double, long, int, int, double, double, int, int, boolean)"><CODE>clusterize(float[][], float[][], float[][], int, double,
 clustering.sfcm.ClusteringDelegate, double, long, int, int, double,
 double, int, int, boolean)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="frobeniusNorm(float[][], float[][])"><!-- --></A><H3>
frobeniusNorm</H3>
<PRE>
private static float <B>frobeniusNorm</B>(float[][]&nbsp;A,
                                   float[][]&nbsp;B)</PRE>
<DL>
<DD>Computes the Frobenius norm of the difference matrix between two input matrixes.
 They must have the same dimensions.
 It is used as a possible criterion to check convergence.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>A</CODE> - a float matrix<DD><CODE>B</CODE> - a float matrix
<DT><B>Returns:</B><DD>the computed  Frobenius norm<DT><B>See Also:</B><DD><A HREF="../../clustering/sfcm/SFCM.html#checkConvergence(float[][], float[][], float[][], float[][], int)"><CODE>checkConvergence(float[][], float[][], float[][], float[][], int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="maxNorm(float[][], float[][])"><!-- --></A><H3>
maxNorm</H3>
<PRE>
private static float <B>maxNorm</B>(float[][]&nbsp;A,
                             float[][]&nbsp;B)</PRE>
<DL>
<DD>Computes the max norm of the difference matrix between two input matrixes.
 They must have the same dimensions.
 It is used as a possible criterion to check convergence.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>A</CODE> - a float matrix<DD><CODE>B</CODE> - a float matrix
<DT><B>Returns:</B><DD>the computed max norm<DT><B>See Also:</B><DD><A HREF="../../clustering/sfcm/SFCM.html#checkConvergence(float[][], float[][], float[][], float[][], int)"><CODE>checkConvergence(float[][], float[][], float[][], float[][], int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="checkConvergence(float[][], float[][], float[][], float[][], int)"><!-- --></A><H3>
checkConvergence</H3>
<PRE>
private static float <B>checkConvergence</B>(float[][]&nbsp;U,
                                      float[][]&nbsp;oldU,
                                      float[][]&nbsp;V,
                                      float[][]&nbsp;oldV,
                                      int&nbsp;criterion)</PRE>
<DL>
<DD>Checks for the convergence of the algorithm. The stopping criterion is
 specified in input.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>U</CODE> - the cluster membership matrix<DD><CODE>oldU</CODE> - the previous iteration cluster membership matrix<DD><CODE>V</CODE> - the cluster center matrix<DD><CODE>oldV</CODE> - the previous iteration cluster center matrix<DD><CODE>criterion</CODE> - is an integer representing one of the possible stop criterions:
 <b>0</b> - it computes the Frobenius norm on the difference between the actual
 membership matrix <code>U</code> and the previous one
 <b>1</b> - it computes the Frobenius norm on the difference between the actual
 centroid matrix <code>V</code> and the previous one
 <b>2</b> - it computes the max norm on the difference between the actual
 membership matrix <code>U</code> and the previous one
 <b>3</b> - it computes the max norm on the difference between the actual
 centroid matrix <code>V</code> and the previous one
<DT><B>Returns:</B><DD>the computed difference according to the chosen criterion<DT><B>See Also:</B><DD><A HREF="../../clustering/sfcm/SFCM.html#clusterize(float[][], float[][], float[][], int, double, clustering.sfcm.ClusteringDelegate, double, long, int, int, double, double, int, int, boolean)"><CODE>clusterize(float[][], float[][], float[][], int, double,
 clustering.sfcm.ClusteringDelegate, double, long, int, int, double,
 double, int, int, boolean)</CODE></A>, 
<A HREF="../../clustering/sfcm/SFCM.html#frobeniusNorm(float[][], float[][])"><CODE>frobeniusNorm(float[][], float[][])</CODE></A>, 
<A HREF="../../clustering/sfcm/SFCM.html#maxNorm(float[][], float[][])"><CODE>maxNorm(float[][], float[][])</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="updateMembershipsWithSpatialInformation(float[][], int, double, double, int, int, int[][], int[][], double[][])"><!-- --></A><H3>
updateMembershipsWithSpatialInformation</H3>
<PRE>
private static float[][] <B>updateMembershipsWithSpatialInformation</B>(float[][]&nbsp;U,
                                                                 int&nbsp;r,
                                                                 double&nbsp;p,
                                                                 double&nbsp;q,
                                                                 int&nbsp;spatialFunctionType,
                                                                 int&nbsp;cols,
                                                                 int[][]&nbsp;xy,
                                                                 int[][]&nbsp;offset,
                                                                 double[][]&nbsp;uPhQ)</PRE>
<DL>
<DD>Updates the cluster membership matrix <code>U</code> according to the
 <i>Spatial Fuzzy C-Means</i> algorithm implemented. It updates each element of
 <code>U</code> by weightening it exponentiating it and multiplying it by the
 exponentiation of a spatial function which in determines the weight of the
 neighborhood for the current sample.
 In order to consider a neighborhood for a sample we reinterpret the sample
 set as a matrix and consider a neighbourhood a window of a certain radius
 centered on the sample (which is a matrix element).
 Different kinds of spatial function are proposed and have to be specified as
 input parameters.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>U</CODE> - the cluster membership matrix to update<DD><CODE>r</CODE> - the radius of the window representing the neighbourhood for a sample<DD><CODE>p</CODE> - the exponent used to weight the membership values<DD><CODE>q</CODE> - the exponent used to weight the spatial function<DD><CODE>spatialFunctionType</CODE> - an integer representing the choosen spatial function:
 <b>0</b> - Computes the spatial function as the sum of the membership values
 for the samples in the neighborhood according to the same cluster
 <b>1</b> - Computes the spatial function as the number of clusters membership
 in the neighborhood that are the greatest value for the neighbor according to
 that cluster<DD><CODE>cols</CODE> - the number of column in the matrix representation of the samples<DD><CODE>xy</CODE> - an integer matrix used to precompute the matrix indices of the matrix form<DD><CODE>offset</CODE> - an integer matrix used to precompute the array indices of
 the array form of the sample<DD><CODE>uPhQ</CODE> - a support matrix used to store the computed value of the update
<DT><B>Returns:</B><DD>the updated cluster membership matrix<DT><B>See Also:</B><DD><A HREF="../../clustering/sfcm/SFCM.html#clusterize(float[][], float[][], float[][], int, double, clustering.sfcm.ClusteringDelegate, double, long, int, int, double, double, int, int, boolean)"><CODE>clusterize(float[][], float[][], float[][], int, double,
 clustering.sfcm.ClusteringDelegate, double, long, int, int, double,
 double, int, int, boolean)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="opt1UpdateMembershipsWithSpatialFunctionH(float[][], int, double, double, int, double[], double[][])"><!-- --></A><H3>
opt1UpdateMembershipsWithSpatialFunctionH</H3>
<PRE>
private static float[][] <B>opt1UpdateMembershipsWithSpatialFunctionH</B>(float[][]&nbsp;U,
                                                                   int&nbsp;rad,
                                                                   double&nbsp;p,
                                                                   double&nbsp;q,
                                                                   int&nbsp;cols,
                                                                   double[]&nbsp;supC,
                                                                   double[][]&nbsp;uPhQ)</PRE>
<DL>
<DD>Computes the update rule of the membership matrix <code>U</code> according
 to the <i>Spatial Fuzzy C-Mean</i> algorithm.
 It implements the spatial function as the sum of the membership values for
 the data belonging to the same neighborhood.
 An optimization is implemented when computing the neighbourhood window.
 An array, with length equal to the
 number of the matrix columns, is used as a queue to compute che sum of the
 window column values and to efficiently and incrementally move the window
 along the columns. For each row the array is initially recomputed from scratch
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>U</CODE> - the cluster membership matrix to update<DD><CODE>rad</CODE> - the window radius<DD><CODE>p</CODE> - the membership weight<DD><CODE>q</CODE> - the spatial function weight<DD><CODE>cols</CODE> - the number of columns in matrix form<DD><CODE>supC</CODE> - the array acting as a queue, if null it will be allocated<DD><CODE>uPhQ</CODE> - a support matrix used to store intermediate computed values,
 if null it will be allocated
<DT><B>Returns:</B><DD>the updated cluster membership matrix</DL>
</DD>
</DL>
<HR>

<A NAME="opt1UpdateMembershipsWithSpatialFunctionG(float[][], int, double, double, int, double[], double[][], short[][])"><!-- --></A><H3>
opt1UpdateMembershipsWithSpatialFunctionG</H3>
<PRE>
private static float[][] <B>opt1UpdateMembershipsWithSpatialFunctionG</B>(float[][]&nbsp;U,
                                                                   int&nbsp;rad,
                                                                   double&nbsp;p,
                                                                   double&nbsp;q,
                                                                   int&nbsp;cols,
                                                                   double[]&nbsp;supC,
                                                                   double[][]&nbsp;uPhQ,
                                                                   short[][]&nbsp;G)</PRE>
<DL>
<DD>Computes the update rule of the membership matrix <code>U</code> according
 to the <i>Spatial Fuzzy C-Mean</i> algorithm.
 It implements the spatial function as the number of the cluster membership values that
 are the greates for every pixel in the neighborhood. So it will compute
 a defuzzyfied version of U and apply the computation on it.
 An optimization is implemented when computing the neighbourhood window.
 An array, with length equal to the
 number of the matrix columns, is used as a queue to compute che sum of the
 window column values and to efficiently and incrementally move the window
 along the columns. For each row the array is initially recomputed from scratch.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>U</CODE> - the cluster membership matrix to update<DD><CODE>rad</CODE> - the window radius<DD><CODE>p</CODE> - the membership weight<DD><CODE>q</CODE> - the spatial function weight<DD><CODE>cols</CODE> - the number of columns in matrix form<DD><CODE>supC</CODE> - the array acting as a queue, if null it will be allocated<DD><CODE>uPhQ</CODE> - a support matrix used to store intermediate computed values,
 if null it will be allocated<DD><CODE>G</CODE> - a support matrix used as
<DT><B>Returns:</B><DD>the updated cluster membership value</DL>
</DD>
</DL>
<HR>

<A NAME="opt2UpdateMembershipsWithSpatialFunctionH(float[][], int, double, double, int, double[][], double[][])"><!-- --></A><H3>
opt2UpdateMembershipsWithSpatialFunctionH</H3>
<PRE>
private static float[][] <B>opt2UpdateMembershipsWithSpatialFunctionH</B>(float[][]&nbsp;U,
                                                                   int&nbsp;rad,
                                                                   double&nbsp;p,
                                                                   double&nbsp;q,
                                                                   int&nbsp;cols,
                                                                   double[][]&nbsp;sumU,
                                                                   double[][]&nbsp;uPhQ)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="opt2UpdateMembershipsWithSpatialFunctionG(float[][], int, double, double, int, int[][], double[][], short[][])"><!-- --></A><H3>
opt2UpdateMembershipsWithSpatialFunctionG</H3>
<PRE>
private static float[][] <B>opt2UpdateMembershipsWithSpatialFunctionG</B>(float[][]&nbsp;U,
                                                                   int&nbsp;rad,
                                                                   double&nbsp;p,
                                                                   double&nbsp;q,
                                                                   int&nbsp;cols,
                                                                   int[][]&nbsp;sumU,
                                                                   double[][]&nbsp;uPhQ,
                                                                   short[][]&nbsp;G)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="precomputeMatrixForm(int, int)"><!-- --></A><H3>
precomputeMatrixForm</H3>
<PRE>
private static int[][] <B>precomputeMatrixForm</B>(int&nbsp;offset,
                                            int&nbsp;width)</PRE>
<DL>
<DD>Precomputes in a samples x 2 matrix the matrix form indices associated
 to each array form indices.
 Deprecated.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>offset</CODE> - the number of samples<DD><CODE>width</CODE> - the number of columns of the matrix form
<DT><B>Returns:</B><DD>the instantiated precomputed matrix<DT><B>See Also:</B><DD><A HREF="../../clustering/sfcm/SFCM.html#updateMembershipsWithSpatialInformation(float[][], int, double, double, int, int, int[][], int[][], double[][])"><CODE>updateMembershipsWithSpatialInformation(float[][], int, double,
 double, int, int, int[][], int[][], double[][])</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="precomputeArrayForm(int, int)"><!-- --></A><H3>
precomputeArrayForm</H3>
<PRE>
private static int[][] <B>precomputeArrayForm</B>(int&nbsp;rows,
                                           int&nbsp;columns)</PRE>
<DL>
<DD>Precomputes in a rows x columns matrix the array form indices associated
 to each pair of matrix form indices.
 Deprecated.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>rows</CODE> - the number of rows in matrix form<DD><CODE>columns</CODE> - the number of columns in matrix form
<DT><B>Returns:</B><DD>the instantiated and precomputed matrix<DT><B>See Also:</B><DD><A HREF="../../clustering/sfcm/SFCM.html#updateMembershipsWithSpatialInformation(float[][], int, double, double, int, int, int[][], int[][], double[][])"><CODE>updateMembershipsWithSpatialInformation(float[][], int, double,
 double, int, int, int[][], int[][], double[][])</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="clusterize(float[][], float[][], float[][], int, double, clustering.sfcm.ClusteringDelegate, double, long, int, int, double, double, int, int, boolean)"><!-- --></A><H3>
clusterize</H3>
<PRE>
private static java.lang.Object[] <B>clusterize</B>(float[][]&nbsp;X,
                                             float[][]&nbsp;U,
                                             float[][]&nbsp;V,
                                             int&nbsp;k,
                                             double&nbsp;tolerance,
                                             <A HREF="../../clustering/sfcm/ClusteringDelegate.html" title="interface in clustering.sfcm">ClusteringDelegate</A>&nbsp;delegate,
                                             double&nbsp;m,
                                             long&nbsp;iterations,
                                             int&nbsp;stopCriterion,
                                             int&nbsp;r,
                                             double&nbsp;p,
                                             double&nbsp;q,
                                             int&nbsp;spatialFunction,
                                             int&nbsp;width,
                                             boolean&nbsp;testing)</PRE>
<DL>
<DD>Clusterize is the main method that orchestrates all the steps of the
 <i>Spatial Fuzzy C-Means</i>algorithm.
 It updates the cluster center matrix <code>V</code>,
 computes the distances between the samples and the cluster centers,
 updates the cluster membership matrix <code>U</code>,
 and updates it again according to an inputted spatial function
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>X</CODE> - data matrix (samples x features)<DD><CODE>U</CODE> - clsuter membership matrix (samples x clusters)<DD><CODE>V</CODE> - cluster centers matrix (clusters x features)<DD><CODE>k</CODE> - number of clusters<DD><CODE>tolerance</CODE> - threshold used to check the convergence between iterations<DD><CODE>delegate</CODE> - the object to which we delegate to update each iteration status<DD><CODE>m</CODE> - the fuzzyness parameter<DD><CODE>iterations</CODE> - the max number of allowed iterations<DD><CODE>stopCriterion</CODE> - is an integer representing one of the possible stop criterions:
 <b>0</b> - it computes the Frobenius norm on the difference between the actual
 membership matrix <code>U</code> and the previous one from the last iteration
 <b>1</b> - it computes the Frobenius norm on the difference between the actual
 centroid matrix <code>V</code> and the previous one from the last iteration
 <b>2</b> - it computes the max norm on the difference between the actual
 membership matrix <code>U</code> and the previous one from the last iteration
 <b>3</b> - it computes the max norm on the difference between the actual
 centroid matrix <code>V</code> and the previous one from the last iteration<DD><CODE>r</CODE> - is the radius of the window representing the neighbourhood for a sample<DD><CODE>p</CODE> - is the weight for the membership value update<DD><CODE>q</CODE> - is the weight for the spatial function<DD><CODE>spatialFunction</CODE> - is an integer representing the choosen spatial function:
 <b>0</b> - Computes the spatial function as the sum of the membership values
 for the samples in the neighborhood according to the same cluster
 <b>1</b> - Computes the spatial function as the number of clusters membership
 in the neighborhood that are the greatest value for the neighbor according to
 that cluster<DD><CODE>width</CODE> - the width of the matrix form, as the samples can be viewed when
 computing the neightborhood for each one<DD><CODE>testing</CODE> - a boolean value that tells whether the algorithm is run for testing
<DT><B>Returns:</B><DD>an array of Objects containing the cluster membership matrix and
 the cluster centroid matrix<DT><B>See Also:</B><DD><A HREF="../../clustering/sfcm/SFCM.html#updateClusterCenterMatrix(float[][], float[][], float[][])"><CODE>updateClusterCenterMatrix(float[][], float[][], float[][])</CODE></A>, 
<A HREF="../../clustering/sfcm/SFCM.html#checkConvergence(float[][], float[][], float[][], float[][], int)"><CODE>checkConvergence(float[][], float[][], float[][], float[][], int)</CODE></A>, 
<A HREF="../../clustering/sfcm/SFCM.html#computeExponentialMembership(float[][], float[][], double)"><CODE>computeExponentialMembership(float[][], float[][], double)</CODE></A>, 
<A HREF="../../clustering/sfcm/SFCM.html#euclideanDistanceMatrix(float[][], float[][], double[][], double)"><CODE>euclideanDistanceMatrix(float[][], float[][], double[][], double)</CODE></A>, 
<A HREF="../../clustering/sfcm/SFCM.html#updateClusterMembershipMatrix(float[][], float[][], float[][], double, double[][])"><CODE>updateClusterMembershipMatrix(float[][], float[][], float[][],
 double, double[][])</CODE></A>, 
<A HREF="../../clustering/sfcm/SFCM.html#updateMembershipsWithSpatialInformation(float[][], int, double, double, int, int, int[][], int[][], double[][])"><CODE>updateMembershipsWithSpatialInformation(float[][], int, double,
 double, int, int, int[][], int[][], double[][])</CODE></A></DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/SFCM.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../clustering/sfcm/ClusteringValidity.html" title="class in clustering.sfcm"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../clustering/sfcm/SFCMManager.html" title="class in clustering.sfcm"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?clustering/sfcm/SFCM.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="SFCM.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
